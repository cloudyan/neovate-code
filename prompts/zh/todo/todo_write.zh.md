---
Name: todo_write
Tools:
Description: 更新后的待办事项列表，待办事项的描述
SystemPrompt:
---

使用此工具为当前编码会话创建和管理结构化任务列表。这有助于您跟踪进度、组织复杂任务并向用户展示您的细致程度。
这也帮助用户了解任务进度和他们请求的总体进度。

## 何时使用此工具
在以下场景中主动使用此工具：

1. 复杂的多步骤任务 - 当任务需要3个或更多不同的步骤或操作时
2. 非琐碎和复杂的任务 - 需要仔细规划或多项操作的任务
3. 用户明确请求待办事项列表 - 当用户直接要求您使用待办事项列表时
4. 用户提供多项任务 - 当用户提供要完成的事项列表时（编号或逗号分隔）
5. 接收到新指令后 - 立即捕获用户需求作为待办事项
6. 开始处理任务时 - 在开始工作前标记为in_progress。理想情况下，您应该一次只有一项待办事项处于in_progress状态
7. 完成任务后 - 标记为已完成，并添加在实施过程中发现的任何新的后续任务

## 何时不使用此工具

在以下情况下跳过使用此工具：
1. 只有一个简单直接的任务
2. 任务很琐碎，跟踪它没有组织上的好处
3. 任务可以在少于3个琐碎步骤内完成
4. 任务纯粹是对话或信息性的

请注意，如果只有一个琐碎的任务要做，您最好不要使用此工具。在这种情况下，您最好直接完成任务。

## 使用待办事项列表的示例

<example>
用户：我想在应用程序设置中添加一个深色模式切换。完成后请确保运行测试和构建！
助手：我会帮助您在应用程序设置中添加深色模式切换。让我创建一个待办事项列表来跟踪这个实现。
*创建包含以下项目的待办事项列表：*
1. 在设置页面创建深色模式切换组件
2. 添加深色模式状态管理（context/store）
3. 为深色主题实现CSS-in-JS样式
4. 更新现有组件以支持主题切换
5. 运行测试和构建过程，解决任何出现的故障或错误
*开始处理第一个任务*

<reasoning>
助手使用待办事项列表是因为：
1. 添加深色模式是一个需要UI、状态管理和样式更改的多步骤功能
2. 用户明确要求之后运行测试和构建
3. 助手推断测试和构建需要通过，因此添加"确保测试和构建成功"作为最终任务
</reasoning>
</example>

<example>
用户：帮我将函数getCwd重命名为getCurrentWorkingDirectory贯穿我的项目
助手：让我先搜索您的代码库以找到'getCwd'的所有出现位置。
*使用grep或搜索工具定位代码库中getCwd的所有实例*
助手：我在8个不同文件中找到了15个'getCwd'实例。让我创建一个待办事项列表来跟踪这些更改。
*为每个需要更新的文件创建特定项目*

<reasoning>
助手使用待办事项列表是因为：
1. 首先，助手搜索以了解任务的范围
2. 在找到多个不同文件中的实例后，确定这是一个具有多个步骤的复杂任务
3. 待办事项列表有助于确保每个实例都被系统地跟踪和更新
4. 这种方法防止遗漏任何实例并保持代码一致性
</reasoning>
</example>

<example>
用户：我需要为我的电子商务网站实现这些功能：用户注册、产品目录、购物车和结账流程。
助手：我会帮助您实现这些功能。首先，让我们把所有功能添加到待办事项列表中。
*创建一个根据项目架构将每个功能分解为特定任务的待办事项列表*
助手：让我们从用户注册开始。这将涉及创建数据库模型、API端点和与您现有身份验证系统集成的前端表单。

<reasoning>
助手使用待办事项列表是因为：
1. 用户提供了一个逗号分隔的多个复杂功能列表来实现
2. 待办事项列表有助于将这些大型功能组织成可管理的任务
3. 这种方法允许跟踪整个实现过程的进度
</reasoning>
</example>

<example>
用户：你能帮我优化我的React应用程序吗？它渲染缓慢且有性能问题。
助手：我会帮助您优化React应用程序。首先，让我检查您的代码库以识别潜在的性能瓶颈。
*审查组件结构、渲染模式、状态管理和数据获取*
助手：在分析您的代码库后，我识别出了几个性能问题。让我创建一个待办事项列表来跟踪我们的优化工作。
*创建包含以下项目的待办事项列表：1) 为ProductList中的昂贵计算实现记忆化，2) 为Dashboard中的长列表添加虚拟化，3) 优化Gallery组件中的图像加载，4) 修复ShoppingCart中的状态更新循环，5) 审查包大小并实现代码分割*
让我们从为您的ProductList组件中的昂贵计算实现记忆化开始。

<reasoning>
助手使用待办事项列表是因为：
1. 首先，助手检查代码库以识别具体的性能问题
2. 基于此分析，识别出了多个优化机会
3. 性能优化是一个需要多个步骤的非琐碎任务
4. 待办事项列表有助于系统地跟踪不同组件的改进
5. 这种系统性方法确保解决所有性能瓶颈
</reasoning>
</example>

## 不使用待办事项列表的示例

<example>
用户：如何在Python中打印'Hello World'？
助手：在Python中，您可以使用以下简单代码打印"Hello World"：

python
print("Hello World")

这将在执行时将文本"Hello World"输出到控制台。
</example>

<reasoning>
助手没有使用待办事项列表，因为这是一个可以在一步内完成的单一、琐碎任务。对于如此直接的请求，没有必要跟踪多个任务或步骤。
</reasoning>
</example>

<example>
用户：git status命令是做什么的？
助手：git status命令显示您的工作目录和暂存区的当前状态。它显示哪些更改已被暂存，哪些没有，以及哪些文件未被Git跟踪。这是在提交之前了解存储库当前状态的基本命令。

<reasoning>
助手没有使用待办事项列表，因为这是一个没有实际编码任务要完成的信息性请求。用户只是在询问解释，而不是要求助手执行多个步骤或任务。
</reasoning>
</example>

<example>
用户：帮我运行npm install并告诉我发生了什么。
助手：我会为您运行npm install命令。

*执行：npm install*

命令成功完成。输出如下：
[npm install命令的输出]

所有依赖项都已根据您的package.json文件安装。

<reasoning>
助手没有使用待办事项列表，因为这是一个具有即时结果的单一命令执行。没有多个步骤需要跟踪或组织，使得待办事项列表对此直接任务来说是不必要的。
</reasoning>
</example>

## 任务状态和管理

1. **任务状态**：使用这些状态来跟踪进度：
   - pending：任务尚未开始
   - in_progress：正在处理中（一次限制一个任务）
   - completed：任务成功完成

2. **任务管理**：
   - 在工作时实时更新任务状态
   - 完成后立即标记任务为完成（不要批量完成）
   - 任何时候只有一项任务处于in_progress状态
   - 在开始新任务前完成当前任务
   - 完全从列表中移除不再相关的任务

3. **任务完成要求**：
   - 仅当您完全完成任务时才标记为完成
   - 如果遇到错误、阻碍或无法完成，保持任务为in_progress状态
   - 当受阻时，创建一个新任务描述需要解决的问题
   - 永远不要在以下情况下标记任务为完成：
     - 测试失败
     - 实现不完整
     - 遇到未解决的错误
     - 找不到必要的文件或依赖项

4. **任务分解**：
   - 创建具体、可操作的项目
   - 将复杂任务分解为更小、可管理的步骤
   - 使用清晰、描述性的任务名称

## 重要
- 返回有效的json输入

## 工具参数示例
{"todos": [{"id": "1", "task": "创建带有棋盘网格的基本HTML结构", "status": "completed"}, {"id": "2", "task": "为棋盘、方格和棋子添加CSS样式", "status": "completed"}, {"id": "3", "task": "实现棋子移动和跳跃的JavaScript游戏逻辑", "status": "in_progress"}, {"id": "4", "task": "添加游戏状态管理（玩家轮流、胜利条件）", "status": "pending"}, {"id": "5", "task": "测试游戏功能并修复任何问题", "status": "pending"}]}

如有疑问，请使用此工具。主动进行任务管理展现了细致入微的态度，并确保您成功完成所有要求。
