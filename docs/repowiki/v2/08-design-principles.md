# 设计原理

> **用途**: 阐述项目技术栈识别和架构识别的设计原理
> **版本**: v2.0

---

## 🎯 技术栈识别设计原理

### 1. 分层递进式识别原理

技术栈识别采用三层递进式架构：
1. **语言层识别**：通过配置文件(package.json、requirements.txt等)识别主要编程语言
2. **框架层识别**：通过依赖声明和代码特征识别使用的框架和库
3. **工具链识别**：通过构建配置和脚本识别开发、测试、部署工具

这种分层设计的优势：
- 逐层深入，逻辑清晰
- 便于调试和问题定位
- 支持部分识别结果的独立验证

### 2. 特征匹配原理

通过多层次特征匹配提高识别准确性：
- **文件特征**：特定文件的存在(如package.json、tsconfig.json等)
- **依赖特征**：依赖声明中的关键库名称
- **代码特征**：代码中的特定模式和API使用
- **配置特征**：构建工具和测试工具的配置文件

特征匹配的实现方式：
```bash
# 文件特征匹配
if [ -f "package.json" ]; then
  echo "检测到Node.js项目"
fi

# 依赖特征匹配
grep -q '"react"' package.json && echo "使用React框架"

# 配置特征匹配
if [ -f "tsconfig.json" ]; then
  echo "使用TypeScript"
fi
```

### 3. 规则引擎原理

使用规则引擎进行决策：
```bash
# 规则示例
if package.json contains "react" and "next" then framework = "Next.js"
if package.json contains "vue" and nuxt.config.ts exists then framework = "Nuxt"
```

规则引擎的优势：
- 决策逻辑清晰透明
- 易于维护和扩展
- 支持复杂的条件组合

### 4. 多源信息融合原理

通过融合多种信息源提高准确性：
- **配置文件信息**：package.json、tsconfig.json等明确声明的信息
- **代码结构信息**：目录结构、文件组织方式
- **代码内容信息**：实际代码中的API使用模式
- **依赖关系信息**：模块间的依赖和调用关系

信息融合策略：
- 主要特征权重较高
- 多个特征一致时提高置信度
- 特征冲突时采用优先级策略

---

## 🏗️ 架构识别设计原理

### 1. 模式匹配原理

架构识别基于预定义的模式进行匹配：
- **文件结构模式**：通过目录结构识别架构模式
- **代码组织模式**：通过代码组织方式识别架构风格
- **配置模式**：通过配置文件识别架构选择

模式匹配示例：
```bash
# 路由架构检测
if [ -d "app" ]; then 
  routing = "file-based"
elif [ -d "src/router" ]; then 
  routing = "config-based"
fi

# 状态管理检测
if [ -d "src/store" ] && grep -q "redux" package.json; then
  state_management = "Redux"
elif grep -q "zustand" package.json; then
  state_management = "Zustand"
fi
```

### 2. 特征检测原理

通过检测关键特征来推断架构：
```bash
# 路由架构检测
if app/ directory exists then routing = "file-based"
if src/router/ exists then routing = "config-based"

# 状态管理检测
if src/store/ and redux dependencies exist then state_management = "Redux"
if zustand dependencies exist then state_management = "Zustand"
```

特征检测的优势：
- 快速识别核心架构特征
- 支持细粒度的架构分析
- 易于扩展新的检测规则

### 3. 关系分析原理

通过分析模块间关系推断架构：
- **依赖关系分析**：分析模块间的依赖方向和强度
- **调用关系分析**：分析函数和组件间的调用模式
- **数据流分析**：分析数据在系统中的流转方式

关系分析方法：
```bash
# 依赖关系分析
grep -r "import" src/ | grep "from" | analyze_dependencies

# 调用关系分析
grep -r "function_call" src/ | analyze_call_graph

# 数据流分析
trace_data_flow(start_point, end_point)
```

### 4. 上下文推断原理

结合多种信息源进行综合推断：
- **项目类型上下文**：CLI工具、Web应用、库等
- **技术栈上下文**：使用的框架和库
- **业务特征上下文**：路由、API、数据模型等

上下文推断策略：
- 基于项目类型调整识别重点
- 结合技术栈特征优化识别算法
- 考虑业务特征影响架构选择

---

## ✅ 提高识别准确性的关键设计

### 1. 多源信息融合

通过融合多种信息源提高准确性：
- **配置文件信息**：package.json、tsconfig.json等明确声明的信息
- **代码结构信息**：目录结构、文件组织方式
- **代码内容信息**：实际代码中的API使用模式
- **依赖关系信息**：模块间的依赖和调用关系

### 2. 分层验证机制

采用分层验证确保识别准确性：
- **初步识别**：基于明显特征的快速识别
- **交叉验证**：通过多种特征进行交叉验证
- **一致性检查**：确保识别结果在不同维度上的一致性
- **异常检测**：识别不一致或矛盾的特征

### 3. 权重评分系统

为不同特征分配权重，综合评分：
```markdown
技术栈识别评分 = 
  文件特征权重 × 文件特征匹配度 +
  依赖特征权重 × 依赖特征匹配度 +
  代码特征权重 × 代码特征匹配度 +
  配置特征权重 × 配置特征匹配度
```

### 4. 上下文感知识别

结合上下文信息提高识别准确性：
- **项目类型上下文**：CLI工具、Web应用、库等不同类型有不同的技术栈偏好
- **业务领域上下文**：电商、内容管理、社交等不同领域有不同的架构模式
- **团队规模上下文**：小团队和大团队可能采用不同的技术栈和架构

### 5. 迭代优化机制

通过反馈机制持续优化识别准确性：
- **人工审核反馈**：将人工审核结果作为训练数据
- **实际使用反馈**：根据文档生成效果调整识别策略
- **版本演进跟踪**：跟踪项目技术栈和架构的演进

---

## 🤖 让大模型准确识别的关键设计

### 1. 角色明确定义

明确大模型的角色和职责：
```markdown
# 角色定义
你是一个专业的代码架构分析师和技术文档工程师，擅长：
- 深度理解复杂代码库的技术栈和架构设计
- 识别项目中使用的技术、框架和工具
- 分析代码组织结构和架构模式
- 生成结构化、高价值的技术分析报告
```

### 2. 任务目标清晰

明确识别任务的具体目标：
```markdown
# 任务目标
分析项目代码库，准确识别以下信息：

## 技术栈识别
1. 编程语言：主要语言和次要语言
2. 框架和库：使用的框架、库和工具
3. 构建工具：编译、打包、测试工具
4. 部署环境：运行环境和部署平台

## 架构识别
1. 架构模式：MVC、DDD、微服务等
2. 代码组织：目录结构和模块划分
3. 数据流模式：数据在系统中的流转方式
4. 交互模式：组件间的交互方式
```

### 3. 分析方法指导

指导大模型使用正确的分析方法：
```markdown
# 分析方法

## 步骤1: 文件结构分析
- 检查项目根目录的配置文件（package.json、requirements.txt等）
- 分析src/目录的组织结构
- 识别关键配置文件（tsconfig.json、webpack.config.js等）

## 步骤2: 依赖关系分析
- 从配置文件中提取依赖信息
- 分析依赖间的关联关系
- 识别核心依赖和辅助依赖

## 步骤3: 代码模式分析
- 查找特定的代码模式和API使用
- 识别框架特有的代码结构
- 分析模块间的调用关系

## 步骤4: 综合判断
- 结合所有信息进行综合判断
- 识别主要技术栈和架构模式
- 给出置信度评分
```

### 4. 输出格式规范

规范输出格式以确保一致性：
```markdown
# 输出格式要求

请按照以下JSON格式输出分析结果：

{
  "tech_stack": {
    "languages": {
      "primary": "主要语言",
      "secondary": ["次要语言1", "次要语言2"]
    },
    "frameworks": {
      "frontend": "前端框架",
      "backend": "后端框架",
      "testing": ["测试框架1", "测试框架2"]
    },
    "build_tools": ["构建工具1", "构建工具2"],
    "deployment": ["部署工具1", "部署工具2"]
  },
  "architecture": {
    "pattern": "主要架构模式",
    "code_organization": "代码组织方式",
    "data_flow": "数据流模式",
    "interaction_model": "交互模式"
  },
  "confidence": {
    "tech_stack": 0.95,  // 置信度评分 0-1
    "architecture": 0.85
  },
  "evidence": {
    "key_files": ["关键文件1", "关键文件2"],
    "key_patterns": ["关键模式1", "关键模式2"]
  }
}
```

### 5. 质量保证约束

确保识别结果的质量：
```markdown
# 质量保证要求

## 准确性要求
- 所有识别结果必须有代码证据支持
- 不能基于假设进行推断
- 对不确定的信息要明确标注置信度

## 完整性要求
- 覆盖技术栈的所有重要方面
- 识别主要和次要的技术选择
- 包含架构的关键特征

## 一致性要求
- 技术栈和架构之间要逻辑一致
- 不同维度的分析结果要相互印证
- 避免矛盾的结论
```

这些设计原理和方法能够确保通用技术方案在面对不同类型项目时都能准确识别技术栈和架构特征，为后续的文档生成提供可靠的基础。
